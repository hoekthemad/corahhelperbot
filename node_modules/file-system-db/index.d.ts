/**
 * A database entry
 */
export type FSDBEntry = {
    /**
     * The unique accessor (id) for the stored data
     */
    key: string;
    /**
     * The data corresponding with the database entry
     */
    value: any;
};
/**
 * A simple, file-based database
 * @see {@link https://github.com/WillTDA/File-System-DB#readme}
 */
export class FSDB {
    /**
     * Create a new FSDB database
     * @param {string} [path="database.json"] You can specify a path to a file
     * location where your database should be located (defaults to
     * "database.json")
     * @param {boolean} [compact=true] Whether or not to store the database
     * contents in a compact format. It won't be easily readable to humans, but
     * it will save storage space (defaults to "true")
     * @example <caption>Creating a human-readable database</caption>
     * const db = new FSDB("./db.json", false);
     */
    constructor(path?: string | undefined, compact?: boolean | undefined);
    path: string;
    /** @private */
    private compact;
    /**
     * @private
     * Retrieves the current data from the database
     * @returns {*} The parsed data from the database
     */
    private readData;
    /**
     * @private
     * Writes the provided data to the database
     * @param {Record<string, any>} data The data to write to the database
     */
    private writeData;
    /**
     * @private
     * Retrieves the value of a key in the database
     * @param {string} key The key of the value to retrieve
     * @param {Record<string, any>} data The object reference
     * @returns {*} The value of the key
     */
    private readEntry;
    /**
     * @private
     * Overwrites the value of a key in the database with the provided value. If
     * the value is `undefined`, the key will be deleted.
     * @param {string} key The key of the value to change, potentially in
     * dot-notation
     * @param {any=} value The new value to change set the key to
     * @param {Record<string, any>} [data=any] The object to write to
     * @param {any} [refEntry=data] The object reference
     */
    private writeEntry;
    /**
     * @private
     * Performs an operation on an array in the database
     * @param {string} method The method that called this function (used for
     * error messages)
     * @param {string} key The key of the array to perform the operation on
     * @param {(currentValue: any[]) => any[]} fn A function that takes the
     * current value and returns the new value (the array operation)
     * @throws {FSDBError} When a parsing or another error occurs
     */
    private setArray;
    /**
     * @private
     * Performs an operation on a numeric value in the database
     * @param {string} method The method that called this function (used for
     * error messages)
     * @param {string} key The key of the number to perform the operation on
     * @param {(currentValue: number) => number} fn A function that takes the
     * current value and returns the new value (the arithmetic operation)
     * @throws {FSDBError} When a parsing or another error occurs
     */
    private setNumber;
    /**
     * Backup all database contents to another JSON file. Compact mode is used
     * on all backups to keep the file size minimal
     * @param {string} path The path to the JSON file you want to backup to
     * @throws {FSDBError} When a file or another error occurs
     * @example <caption>Backing up the database</caption>
     * db.backup("./Backups/db-backup.json");
     */
    backup(path: string): void;
    /**
     * Delete a value from the database
     * @param {string} key The key of the data you want to delete
     * @throws {FSDBError} When a parsing or another error occurs
     * @example <caption>Deleting a value</caption>
     * db.delete("key");
     * @example <caption>Deleting a value using dot notation</caption>
     * db.delete("foo.bar");
     */
    delete(key: string): void;
    /**
     * Delete all data from the database (this CANNOT be undone!)
     * @throws {FSDBError} When a file or another error occurs
     * @example <caption>Deleting all data</caption>
     * db.deleteAll();
     */
    deleteAll(): void;
    /**
     * Retrieve a value from the database
     * @param {string} key The key of the data you want to retrieve
     * @returns {any} The data found (`undefined` if not found)
     * @throws {FSDBError} If no key was provided
     * @example <caption>Retrieving a value</caption>
     * db.get("key");
     * // => "value"
     */
    get(key: string): any;
    /**
     * Fetch all data from the database
     * @param {boolean=} verbose Whether or not to escape dot notation and class
     * those as individual entries (defaults to "false")
     * @returns {FSDBEntry[]} All data in the database
     * @throws {FSDBError} If the database could not be parsed
     * @example <caption>With "verbose" disabled</caption>
     * db.getAll(false);
     * // => [{ key: "key", value: "value" }, { key: "foo", value: { "bar": "value" } }]
     * @example <caption>With "verbose" enabled</caption>
     * db.getAll(true);
     * // => [{ key: "key", value: "value" }, { key: "foo.bar", value: "value" }]
     */
    getAll(verbose?: boolean | undefined): FSDBEntry[];
    /**
     * Check if a key exists in the database
     * @param {string} key The key to check
     * @returns {boolean} Whether the key exists
     * @throws {FSDBError} If no key was provided
     * @example <caption>Check if ""key"" exists</caption>
     * db.has("key");
     * // => true
     */
    has(key: string): boolean;
    /**
     * Save a value to the database
     * @param {string} key The key of the data you want to save
     * @param {any} value The value you want to save
     * @example <caption>Saving a value</caption>
     * db.set("key", "value");
     * // => { key: "value" }
     * @example <caption>Saving a value with dot notation</caption>
     * db.set("foo.bar", "value");
     * // => { foo: { bar: "value" } }
     */
    set(key: string, value: any): void;
    /**
     * Retrieve a list of entries starting with a provided query
     * @param {string} query The search query to filter against
     * @returns {FSDBEntry[]} A list of entries starting with the provided query
     * @throws {FSDBError}
     * @example <caption>Retrieve entries starting with `"key"`</caption>
     * db.startsWith("key");
     * // => [{ key: "key.foo", value: "value" }, { key: "key.bar", value: "value" }]
     */
    startsWith(query: string): FSDBEntry[];
    /**
     * Push value(s) to an array in the database
     * @param {string} key The key of the array you want to push to
     * @param {any[]} items The value(s) you want to push
     * @throws {FSDBError}
     * @example <caption>Pushing a value</caption>
     * db.push("key", "value");
     * // => { key: ["value"] }
     * @example <caption>Pushing multiple values</caption>
     * db.push("key", "foo", "bar");
     * // => { key: ["value", "foo", "bar"] }
     */
    push(key: string, ...items: any[]): void;
    /**
     * Remove value(s) from an array in the database
     * @param {string} key The key of the array you want to remove from
     * @param {any[]} items The value(s) you want to remove
     * @throws {FSDBError}
     * @example <caption>Removing a value</caption>
     * db.pull("key", "value");
     * // => { key: [] }
     */
    pull(key: string, ...items: any[]): void;
    /**
     * Add to a numeric value in the database
     * @param {string} key The key of the number you want to add to
     * @param {number} value The value you want to add
     * @throws {FSDBError}
     * @example <caption>Adding to a number</caption>
     * // assuming the database contains: { key: 500 }
     * db.add("key", 250);
     * // => { key: 750 }
     */
    add(key: string, value: number): void;
    /**
     * Subtract from a numeric value in the database
     * @param {string} key The key of the number you want to subtract from
     * @param {number} value The value you want to subtract
     * @throws {FSDBError}
     * @example <caption>Subtracting from a number</caption>
     * // assuming the database contains: { key: 500 }
     * db.subtract("key", 100);
     * // => { key: 400 }
     */
    subtract(key: string, value: number): void;
    /**
     * Multiply a numeric value in the database
     * @param {string} key The key of the number you want to multiply
     * @param {number} value The value you want to multiply by
     * @throws {FSDBError}
     * @example <caption>Multiplying a number</caption>
     * // assuming the database contains: { key: 500 }
     * db.multiply("key", 2);
     * // => { key: 1000 }
     */
    multiply(key: string, value: number): void;
    /**
     * Divide a numeric value in the database
     * @param {string} key The key of the number you want to divide
     * @param {number} value The value you want to divide by
     * @throws {FSDBError}
     * @example <caption>Dividing a number</caption>
     * // assuming the database contains: { key: 500 }
     * db.divide("key", 2);
     * // => { key: 250 }
     */
    divide(key: string, value: number): void;
}
/** A custom error class for handling errors within an FSDB instance */
export class FSDBError extends Error {
    /**
     * Create a new FSDBError instance
     * @param {object} options The options for the error
     * @param {string} options.message The error message
     * @param {string} options.method The method that threw the error
     * @param {unknown=} options.cause The cause of the error
     */
    constructor({ message, method, cause }: {
        message: string;
        method: string;
        cause?: unknown | undefined;
    });
    method: string;
    cause: unknown;
}
//# sourceMappingURL=index.d.ts.map